#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
TelegramÂºÇÊ≠•‰ªªÂä°Ê®°Âùó - Âü∫‰∫éSQLiteÁöÑËΩªÈáèÁ∫ßÂºÇÊ≠•‰∏ä‰º†

‰ΩøÁî®SQLiteÊï∞ÊçÆÂ∫ìÂÆûÁé∞ÂºÇÊ≠•‰ªªÂä°ÈòüÂàóÔºåÊó†ÈúÄÂ§ñÈÉ®‰æùËµñ
"""

import os
import sys
import time
import json
import uuid
import sqlite3
import logging
import threading
from pathlib import Path
from typing import Dict, Any, Optional, List
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor

# Ê∑ªÂä†È°πÁõÆÊ†πÁõÆÂΩïÂà∞PythonË∑ØÂæÑ
current_dir = Path(__file__).parent.parent.parent
sys.path.insert(0, str(current_dir))

logger = logging.getLogger(__name__)


class SQLiteTaskQueue:
    """Âü∫‰∫éSQLiteÁöÑËΩªÈáèÁ∫ß‰ªªÂä°ÈòüÂàó"""
    
    def __init__(self, db_path: str = None):
        if db_path is None:
            # ‰ΩøÁî®È°πÁõÆÊï∞ÊçÆÂ∫ìË∑ØÂæÑ
            self.db_path = "data/app.db"
        else:
            self.db_path = db_path
        
        self.executor = ThreadPoolExecutor(max_workers=4)
        self._init_tables()
        self._running = False
        self._worker_thread = None
    
    def _init_tables(self):
        """ÂàùÂßãÂåñ‰ªªÂä°Ë°®"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute('''
                    CREATE TABLE IF NOT EXISTS upload_tasks (
                        id TEXT PRIMARY KEY,
                        task_type TEXT NOT NULL,
                        status TEXT NOT NULL DEFAULT 'pending',
                        file_path TEXT,
                        file_paths TEXT,  -- JSONÊ†ºÂºèÂ≠òÂÇ®Â§öÊñá‰ª∂Ë∑ØÂæÑ
                        caption TEXT,
                        config TEXT,  -- JSONÊ†ºÂºèÂ≠òÂÇ®ÈÖçÁΩÆ
                        progress INTEGER DEFAULT 0,
                        current_file TEXT,
                        completed_files INTEGER DEFAULT 0,
                        total_files INTEGER DEFAULT 1,
                        result TEXT,  -- JSONÊ†ºÂºèÂ≠òÂÇ®ÁªìÊûú
                        error_message TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                ''')
                
                # ÂàõÂª∫Á¥¢Âºï
                conn.execute('CREATE INDEX IF NOT EXISTS idx_upload_tasks_status ON upload_tasks(status)')
                conn.execute('CREATE INDEX IF NOT EXISTS idx_upload_tasks_created ON upload_tasks(created_at)')
                
                logger.info("‚úÖ SQLite‰ªªÂä°ÈòüÂàóË°®ÂàùÂßãÂåñÊàêÂäü")
                
        except Exception as e:
            logger.error(f"‚ùå ÂàùÂßãÂåñ‰ªªÂä°ÈòüÂàóË°®Â§±Ë¥•: {e}")
            raise
    
    def submit_task(self, task_type: str, **kwargs) -> str:
        """Êèê‰∫§‰ªªÂä°Âà∞ÈòüÂàó"""
        task_id = str(uuid.uuid4())
        
        try:
            with sqlite3.connect(self.db_path) as conn:
                # Â§ÑÁêÜ‰∏çÂêåÁ±ªÂûãÁöÑ‰ªªÂä°ÂèÇÊï∞
                file_path = kwargs.get('file_path')
                file_paths = kwargs.get('file_paths')
                caption = kwargs.get('caption', '')
                config = kwargs.get('config', {})
                
                # ËÆ°ÁÆóÊÄªÊñá‰ª∂Êï∞
                if file_paths:
                    total_files = len(file_paths)
                    file_paths_json = json.dumps(file_paths)
                else:
                    total_files = 1
                    file_paths_json = None
                
                conn.execute('''
                    INSERT INTO upload_tasks 
                    (id, task_type, file_path, file_paths, caption, config, total_files)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                ''', (
                    task_id, task_type, file_path, file_paths_json, 
                    caption, json.dumps(config), total_files
                ))
                
                logger.info(f"‚úÖ ‰ªªÂä°Â∑≤Êèê‰∫§Âà∞ÈòüÂàó: {task_id} ({task_type})")
                
                # ÂêØÂä®Â∑•‰ΩúÁ∫øÁ®ãÔºàÂ¶ÇÊûúËøòÊ≤°ÂêØÂä®Ôºâ
                self._ensure_worker_running()
                
                return task_id
                
        except Exception as e:
            logger.error(f"‚ùå Êèê‰∫§‰ªªÂä°Â§±Ë¥•: {e}")
            return None
    
    def get_task_status(self, task_id: str) -> Dict[str, Any]:
        """Ëé∑Âèñ‰ªªÂä°Áä∂ÊÄÅ"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.row_factory = sqlite3.Row
                cursor = conn.execute('''
                    SELECT * FROM upload_tasks WHERE id = ?
                ''', (task_id,))
                
                row = cursor.fetchone()
                if not row:
                    return {'status': 'not_found', 'error': '‰ªªÂä°‰∏çÂ≠òÂú®'}
                
                # ÊûÑÂª∫Áä∂ÊÄÅÂìçÂ∫î
                status_data = {
                    'status': row['status'],
                    'progress': row['progress'],
                    'current_file': row['current_file'],
                    'completed_files': row['completed_files'],
                    'total_files': row['total_files'],
                    'created_at': row['created_at'],
                    'updated_at': row['updated_at']
                }
                
                # Ê∑ªÂä†ÁªìÊûúÊàñÈîôËØØ‰ø°ÊÅØ
                if row['status'] == 'completed' and row['result']:
                    status_data['result'] = json.loads(row['result'])
                elif row['status'] == 'failed' and row['error_message']:
                    status_data['error'] = row['error_message']
                
                return status_data
                
        except Exception as e:
            logger.error(f"‚ùå Ëé∑Âèñ‰ªªÂä°Áä∂ÊÄÅÂ§±Ë¥•: {e}")
            return {'status': 'error', 'error': str(e)}
    
    def update_task_progress(self, task_id: str, progress: int, current_file: str = None, completed_files: int = None):
        """Êõ¥Êñ∞‰ªªÂä°ËøõÂ∫¶"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                update_fields = ['progress = ?', 'updated_at = CURRENT_TIMESTAMP']
                params = [progress]
                
                if current_file:
                    update_fields.append('current_file = ?')
                    params.append(current_file)
                
                if completed_files is not None:
                    update_fields.append('completed_files = ?')
                    params.append(completed_files)
                
                params.append(task_id)
                
                conn.execute(f'''
                    UPDATE upload_tasks 
                    SET {', '.join(update_fields)}
                    WHERE id = ?
                ''', params)
                
        except Exception as e:
            logger.error(f"‚ùå Êõ¥Êñ∞‰ªªÂä°ËøõÂ∫¶Â§±Ë¥•: {e}")
    
    def complete_task(self, task_id: str, result: Dict[str, Any]):
        """Ê†áËÆ∞‰ªªÂä°ÂÆåÊàê"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute('''
                    UPDATE upload_tasks 
                    SET status = 'completed', result = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE id = ?
                ''', (json.dumps(result), task_id))
                
                logger.info(f"‚úÖ ‰ªªÂä°ÂÆåÊàê: {task_id}")
                
        except Exception as e:
            logger.error(f"‚ùå Ê†áËÆ∞‰ªªÂä°ÂÆåÊàêÂ§±Ë¥•: {e}")
    
    def fail_task(self, task_id: str, error_message: str):
        """Ê†áËÆ∞‰ªªÂä°Â§±Ë¥•"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.execute('''
                    UPDATE upload_tasks 
                    SET status = 'failed', error_message = ?, updated_at = CURRENT_TIMESTAMP
                    WHERE id = ?
                ''', (error_message, task_id))
                
                logger.error(f"‚ùå ‰ªªÂä°Â§±Ë¥•: {task_id} - {error_message}")
                
        except Exception as e:
            logger.error(f"‚ùå Ê†áËÆ∞‰ªªÂä°Â§±Ë¥•Â§±Ë¥•: {e}")
    
    def _ensure_worker_running(self):
        """Á°Æ‰øùÂ∑•‰ΩúÁ∫øÁ®ãÊ≠£Âú®ËøêË°å"""
        if not self._running:
            self._running = True
            self._worker_thread = threading.Thread(target=self._worker_loop, daemon=True)
            self._worker_thread.start()
            logger.info("üöÄ SQLite‰ªªÂä°ÈòüÂàóÂ∑•‰ΩúÁ∫øÁ®ãÂ∑≤ÂêØÂä®")
    
    def _worker_loop(self):
        """Â∑•‰ΩúÁ∫øÁ®ã‰∏ªÂæ™ÁéØ"""
        while self._running:
            try:
                # Ëé∑ÂèñÂæÖÂ§ÑÁêÜ‰ªªÂä°
                pending_tasks = self._get_pending_tasks()
                
                if not pending_tasks:
                    time.sleep(1)  # Ê≤°Êúâ‰ªªÂä°Êó∂‰ºëÁú†1Áßí
                    continue
                
                # Â§ÑÁêÜ‰ªªÂä°Ôºà‰ΩøÁî®Á∫øÁ®ãÊ±†Ôºâ
                for task in pending_tasks:
                    self.executor.submit(self._process_task, task)
                
                time.sleep(0.5)  # Áü≠ÊöÇ‰ºëÁú†ÈÅøÂÖçËøáÂ∫¶ËΩÆËØ¢
                
            except Exception as e:
                logger.error(f"‚ùå Â∑•‰ΩúÁ∫øÁ®ãÈîôËØØ: {e}")
                time.sleep(5)  # Âá∫ÈîôÊó∂‰ºëÁú†5Áßí
    
    def _get_pending_tasks(self, limit: int = 4) -> List[Dict]:
        """Ëé∑ÂèñÂæÖÂ§ÑÁêÜ‰ªªÂä°"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                conn.row_factory = sqlite3.Row
                cursor = conn.execute('''
                    SELECT * FROM upload_tasks 
                    WHERE status = 'pending' 
                    ORDER BY created_at ASC 
                    LIMIT ?
                ''', (limit,))
                
                tasks = []
                for row in cursor.fetchall():
                    # Ê†áËÆ∞‰∏∫Â§ÑÁêÜ‰∏≠
                    conn.execute('''
                        UPDATE upload_tasks 
                        SET status = 'processing', updated_at = CURRENT_TIMESTAMP
                        WHERE id = ?
                    ''', (row['id'],))
                    
                    tasks.append(dict(row))
                
                return tasks
                
        except Exception as e:
            logger.error(f"‚ùå Ëé∑ÂèñÂæÖÂ§ÑÁêÜ‰ªªÂä°Â§±Ë¥•: {e}")
            return []

    def _process_task(self, task: Dict):
        """Â§ÑÁêÜÂçï‰∏™‰ªªÂä°"""
        task_id = task['id']
        task_type = task['task_type']

        try:
            logger.info(f"üöÄ ÂºÄÂßãÂ§ÑÁêÜ‰ªªÂä°: {task_id} ({task_type})")

            if task_type == 'upload_file':
                self._process_upload_file(task)
            elif task_type == 'batch_upload':
                self._process_batch_upload(task)
            elif task_type == 'send_message':
                self._process_send_message(task)
            else:
                raise ValueError(f"Êú™Áü•‰ªªÂä°Á±ªÂûã: {task_type}")

        except Exception as e:
            logger.error(f"‚ùå Â§ÑÁêÜ‰ªªÂä°Â§±Ë¥•: {task_id} - {e}")
            self.fail_task(task_id, str(e))

    def _process_upload_file(self, task: Dict):
        """Â§ÑÁêÜÂçïÊñá‰ª∂‰∏ä‰º†‰ªªÂä°"""
        task_id = task['id']
        file_path = task['file_path']
        caption = task['caption'] or ''
        config = json.loads(task['config']) if task['config'] else {}

        try:
            # Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â≠òÂú®
            file_path_obj = Path(file_path)
            if not file_path_obj.exists():
                raise FileNotFoundError(f"Êñá‰ª∂‰∏çÂ≠òÂú®: {file_path}")

            # Êõ¥Êñ∞ËøõÂ∫¶
            self.update_task_progress(task_id, 10, file_path)

            # ÂàõÂª∫‰∏ä‰º†Âô®
            from modules.telegram.uploaders.modern_hybrid import ModernHybridUploader

            if not config:
                from modules.telegram.services.config_service import get_telegram_config_service
                config_service = get_telegram_config_service()
                config = config_service.get_config()

            uploader = ModernHybridUploader(config)

            if not uploader.is_available():
                raise RuntimeError("Ê≤°ÊúâÂèØÁî®ÁöÑTelegram‰∏ä‰º†Âô®")

            # Êõ¥Êñ∞ËøõÂ∫¶
            self.update_task_progress(task_id, 20)

            # ÊâßË°å‰∏ä‰º†
            result = uploader.send_file(file_path, caption)

            if result:
                file_size_mb = file_path_obj.stat().st_size / (1024 * 1024)
                self.complete_task(task_id, {
                    'status': 'success',
                    'file_path': file_path,
                    'file_size_mb': round(file_size_mb, 2),
                    'upload_time': time.time()
                })
                logger.info(f"‚úÖ Êñá‰ª∂‰∏ä‰º†ÊàêÂäü: {file_path}")
            else:
                raise RuntimeError("‰∏ä‰º†Â§±Ë¥•")

        except Exception as e:
            self.fail_task(task_id, str(e))
            raise

    def _process_batch_upload(self, task: Dict):
        """Â§ÑÁêÜÊâπÈáè‰∏ä‰º†‰ªªÂä°"""
        task_id = task['id']
        file_paths = json.loads(task['file_paths']) if task['file_paths'] else []
        caption = task['caption'] or ''
        config = json.loads(task['config']) if task['config'] else {}

        try:
            # È™åËØÅÊñá‰ª∂
            valid_files = []
            invalid_files = []

            for file_path in file_paths:
                if Path(file_path).exists():
                    valid_files.append(file_path)
                else:
                    invalid_files.append(file_path)

            if not valid_files:
                raise FileNotFoundError("Ê≤°ÊúâÊúâÊïàÁöÑÊñá‰ª∂ÂèØ‰ª•‰∏ä‰º†")

            # Êõ¥Êñ∞ËøõÂ∫¶
            self.update_task_progress(task_id, 10, completed_files=0)

            # ÂàõÂª∫‰∏ä‰º†Âô®
            from modules.telegram.uploaders.modern_hybrid import ModernHybridUploader

            if not config:
                from modules.telegram.services.config_service import get_telegram_config_service
                config_service = get_telegram_config_service()
                config = config_service.get_config()

            uploader = ModernHybridUploader(config)

            if not uploader.is_available():
                raise RuntimeError("Ê≤°ÊúâÂèØÁî®ÁöÑTelegram‰∏ä‰º†Âô®")

            # ÊâπÈáè‰∏ä‰º†
            successful_uploads = []
            failed_uploads = []

            for i, file_path in enumerate(valid_files):
                try:
                    # Êõ¥Êñ∞ËøõÂ∫¶
                    progress = 10 + (i / len(valid_files)) * 80
                    self.update_task_progress(task_id, int(progress), file_path, i)

                    logger.info(f"üì§ ‰∏ä‰º†Êñá‰ª∂ {i+1}/{len(valid_files)}: {file_path}")

                    result = uploader.send_file(file_path, caption)

                    if result:
                        successful_uploads.append(file_path)
                    else:
                        failed_uploads.append(file_path)

                except Exception as e:
                    logger.error(f"‚ùå Êñá‰ª∂‰∏ä‰º†ÂºÇÂ∏∏: {file_path} - {e}")
                    failed_uploads.append(file_path)

            # ÂÆåÊàê‰ªªÂä°
            success_rate = len(successful_uploads) / len(valid_files) * 100 if valid_files else 0

            self.complete_task(task_id, {
                'status': 'completed',
                'total_files': len(file_paths),
                'valid_files': len(valid_files),
                'invalid_files': len(invalid_files),
                'successful_uploads': len(successful_uploads),
                'failed_uploads': len(failed_uploads),
                'success_rate': round(success_rate, 2),
                'successful_files': successful_uploads,
                'failed_files': failed_uploads,
                'invalid_files': invalid_files
            })

            logger.info(f"‚úÖ ÊâπÈáè‰∏ä‰º†ÂÆåÊàê: {len(successful_uploads)}/{len(valid_files)} ÊàêÂäü")

        except Exception as e:
            self.fail_task(task_id, str(e))
            raise

    def _process_send_message(self, task: Dict):
        """Â§ÑÁêÜÊ∂àÊÅØÂèëÈÄÅ‰ªªÂä°"""
        task_id = task['id']
        message = task['caption']  # Â§çÁî®captionÂ≠óÊÆµÂ≠òÂÇ®Ê∂àÊÅØÂÜÖÂÆπ
        config = json.loads(task['config']) if task['config'] else {}

        try:
            # ÂàõÂª∫‰∏ä‰º†Âô®
            from modules.telegram.uploaders.modern_hybrid import ModernHybridUploader

            if not config:
                from modules.telegram.services.config_service import get_telegram_config_service
                config_service = get_telegram_config_service()
                config = config_service.get_config()

            uploader = ModernHybridUploader(config)

            if not uploader.is_available():
                raise RuntimeError("Ê≤°ÊúâÂèØÁî®ÁöÑTelegram‰∏ä‰º†Âô®")

            # ÂèëÈÄÅÊ∂àÊÅØ
            result = uploader.send_message(message)

            if result:
                self.complete_task(task_id, {
                    'status': 'success',
                    'message_length': len(message)
                })
                logger.info(f"‚úÖ Ê∂àÊÅØÂèëÈÄÅÊàêÂäü")
            else:
                raise RuntimeError("Ê∂àÊÅØÂèëÈÄÅÂ§±Ë¥•")

        except Exception as e:
            self.fail_task(task_id, str(e))
            raise

    def get_queue_status(self) -> Dict[str, Any]:
        """Ëé∑ÂèñÈòüÂàóÁä∂ÊÄÅ"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.execute('''
                    SELECT status, COUNT(*) as count
                    FROM upload_tasks
                    GROUP BY status
                ''')

                status_counts = {}
                for row in cursor.fetchall():
                    status_counts[row[0]] = row[1]

                return {
                    'pending': status_counts.get('pending', 0),
                    'processing': status_counts.get('processing', 0),
                    'completed': status_counts.get('completed', 0),
                    'failed': status_counts.get('failed', 0),
                    'total': sum(status_counts.values())
                }

        except Exception as e:
            logger.error(f"‚ùå Ëé∑ÂèñÈòüÂàóÁä∂ÊÄÅÂ§±Ë¥•: {e}")
            return {'error': str(e)}

    def cleanup_completed_tasks(self, days: int = 7) -> int:
        """Ê∏ÖÁêÜÂ∑≤ÂÆåÊàêÁöÑ‰ªªÂä°"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.execute('''
                    DELETE FROM upload_tasks
                    WHERE status IN ('completed', 'failed')
                    AND created_at < datetime('now', '-{} days')
                '''.format(days))

                cleaned_count = cursor.rowcount
                logger.info(f"üßπ Ê∏ÖÁêÜ‰∫Ü {cleaned_count} ‰∏™ËøáÊúü‰ªªÂä°")
                return cleaned_count

        except Exception as e:
            logger.error(f"‚ùå Ê∏ÖÁêÜ‰ªªÂä°Â§±Ë¥•: {e}")
            return 0

    def stop(self):
        """ÂÅúÊ≠¢Â∑•‰ΩúÁ∫øÁ®ã"""
        self._running = False
        if self._worker_thread:
            self._worker_thread.join(timeout=5)
        self.executor.shutdown(wait=True)
        logger.info("üõë SQLite‰ªªÂä°ÈòüÂàóÂ∑≤ÂÅúÊ≠¢")


# ÂÖ®Â±Ä‰ªªÂä°ÈòüÂàóÂÆû‰æã
_task_queue = None

def get_task_queue() -> SQLiteTaskQueue:
    """Ëé∑ÂèñÂÖ®Â±Ä‰ªªÂä°ÈòüÂàóÂÆû‰æã"""
    global _task_queue
    if _task_queue is None:
        _task_queue = SQLiteTaskQueue()
    return _task_queue


class TelegramTaskManager:
    """Telegram‰ªªÂä°ÁÆ°ÁêÜÂô® - Âü∫‰∫éSQLiteÁöÑËΩªÈáèÁ∫ßÂÆûÁé∞"""

    def __init__(self):
        self.task_queue = get_task_queue()

    def is_async_available(self) -> bool:
        """Ê£ÄÊü•ÂºÇÊ≠•ÂäüËÉΩÊòØÂê¶ÂèØÁî®"""
        return True  # SQLiteÈòüÂàóÊÄªÊòØÂèØÁî®

    def submit_upload_task(self, file_path: str, caption: str = None, config: Dict[str, Any] = None, **kwargs) -> Optional[str]:
        """Êèê‰∫§‰∏ä‰º†‰ªªÂä°"""
        try:
            task_id = self.task_queue.submit_task(
                'upload_file',
                file_path=file_path,
                caption=caption,
                config=config or {}
            )

            if task_id:
                logger.info(f"‚úÖ ‰∏ä‰º†‰ªªÂä°Â∑≤Êèê‰∫§: {task_id}")
                return task_id
            else:
                logger.error("‚ùå Êèê‰∫§‰∏ä‰º†‰ªªÂä°Â§±Ë¥•")
                return None

        except Exception as e:
            logger.error(f"‚ùå Êèê‰∫§‰∏ä‰º†‰ªªÂä°Â§±Ë¥•: {e}")
            return None

    def submit_batch_upload_task(self, file_paths: list, caption: str = None, config: Dict[str, Any] = None, **kwargs) -> Optional[str]:
        """Êèê‰∫§ÊâπÈáè‰∏ä‰º†‰ªªÂä°"""
        try:
            task_id = self.task_queue.submit_task(
                'batch_upload',
                file_paths=file_paths,
                caption=caption,
                config=config or {}
            )

            if task_id:
                logger.info(f"‚úÖ ÊâπÈáè‰∏ä‰º†‰ªªÂä°Â∑≤Êèê‰∫§: {task_id} ({len(file_paths)} ‰∏™Êñá‰ª∂)")
                return task_id
            else:
                logger.error("‚ùå Êèê‰∫§ÊâπÈáè‰∏ä‰º†‰ªªÂä°Â§±Ë¥•")
                return None

        except Exception as e:
            logger.error(f"‚ùå Êèê‰∫§ÊâπÈáè‰∏ä‰º†‰ªªÂä°Â§±Ë¥•: {e}")
            return None

    def submit_message_task(self, message: str, config: Dict[str, Any] = None, **kwargs) -> Optional[str]:
        """Êèê‰∫§Ê∂àÊÅØ‰ªªÂä°"""
        try:
            task_id = self.task_queue.submit_task(
                'send_message',
                caption=message,  # Â§çÁî®captionÂ≠óÊÆµ
                config=config or {}
            )

            if task_id:
                logger.info(f"‚úÖ Ê∂àÊÅØ‰ªªÂä°Â∑≤Êèê‰∫§: {task_id}")
                return task_id
            else:
                logger.error("‚ùå Êèê‰∫§Ê∂àÊÅØ‰ªªÂä°Â§±Ë¥•")
                return None

        except Exception as e:
            logger.error(f"‚ùå Êèê‰∫§Ê∂àÊÅØ‰ªªÂä°Â§±Ë¥•: {e}")
            return None

    def get_task_status(self, task_id: str) -> Dict[str, Any]:
        """Ëé∑Âèñ‰ªªÂä°Áä∂ÊÄÅ"""
        return self.task_queue.get_task_status(task_id)

    def get_queue_status(self) -> Dict[str, Any]:
        """Ëé∑ÂèñÈòüÂàóÁä∂ÊÄÅ"""
        return self.task_queue.get_queue_status()

    def cleanup_completed_tasks(self) -> int:
        """Ê∏ÖÁêÜÂ∑≤ÂÆåÊàêÁöÑ‰ªªÂä°"""
        return self.task_queue.cleanup_completed_tasks()

    def get_all_tasks(self) -> Dict[str, Any]:
        """Ëé∑ÂèñÊâÄÊúâ‰ªªÂä°ÔºàÊúÄËøëÁöÑ100‰∏™Ôºâ"""
        try:
            with sqlite3.connect(self.task_queue.db_path) as conn:
                conn.row_factory = sqlite3.Row
                cursor = conn.execute('''
                    SELECT id, task_type, status, progress, created_at, updated_at
                    FROM upload_tasks
                    ORDER BY created_at DESC
                    LIMIT 100
                ''')

                tasks = {}
                for row in cursor.fetchall():
                    tasks[row['id']] = {
                        'type': row['task_type'],
                        'status': row['status'],
                        'progress': row['progress'],
                        'created_at': row['created_at'],
                        'updated_at': row['updated_at']
                    }

                return tasks

        except Exception as e:
            logger.error(f"‚ùå Ëé∑Âèñ‰ªªÂä°ÂàóË°®Â§±Ë¥•: {e}")
            return {}

    def cancel_task(self, task_id: str) -> bool:
        """ÂèñÊ∂à‰ªªÂä°ÔºàÊ†áËÆ∞‰∏∫Â§±Ë¥•Ôºâ"""
        try:
            self.task_queue.fail_task(task_id, "Áî®Êà∑ÂèñÊ∂à")
            logger.info(f"‚úÖ ‰ªªÂä°Â∑≤ÂèñÊ∂à: {task_id}")
            return True
        except Exception as e:
            logger.error(f"‚ùå ÂèñÊ∂à‰ªªÂä°Â§±Ë¥•: {e}")
            return False


# ÂÖ®Â±Ä‰ªªÂä°ÁÆ°ÁêÜÂô®ÂÆû‰æã
_task_manager = None

def get_task_manager() -> TelegramTaskManager:
    """Ëé∑Âèñ‰ªªÂä°ÁÆ°ÁêÜÂô®ÂÆû‰æã"""
    global _task_manager
    if _task_manager is None:
        _task_manager = TelegramTaskManager()
    return _task_manager


# ÂÖºÂÆπÊÄßÂáΩÊï∞Ôºà‰øùÊåÅAPI‰∏ÄËá¥ÊÄßÔºâ
def upload_file_async(*args, **kwargs):
    """ÂÖºÂÆπÊÄßÂáΩÊï∞ - ÂºÇÊ≠•‰∏ä‰º†Êñá‰ª∂"""
    task_manager = get_task_manager()
    return task_manager.submit_upload_task(*args, **kwargs)

def send_message_async(*args, **kwargs):
    """ÂÖºÂÆπÊÄßÂáΩÊï∞ - ÂºÇÊ≠•ÂèëÈÄÅÊ∂àÊÅØ"""
    task_manager = get_task_manager()
    return task_manager.submit_message_task(*args, **kwargs)

def batch_upload_async(*args, **kwargs):
    """ÂÖºÂÆπÊÄßÂáΩÊï∞ - ÊâπÈáèÂºÇÊ≠•‰∏ä‰º†"""
    task_manager = get_task_manager()
    return task_manager.submit_batch_upload_task(*args, **kwargs)


if __name__ == "__main__":
    # ÊµãËØïSQLite‰ªªÂä°ÈòüÂàó
    print("üß™ ÊµãËØïSQLite‰ªªÂä°ÈòüÂàó")

    task_queue = SQLiteTaskQueue()

    # Êèê‰∫§ÊµãËØï‰ªªÂä°
    task_id = task_queue.submit_task('send_message', caption='ÊµãËØïÊ∂àÊÅØ')
    print(f"‰ªªÂä°ID: {task_id}")

    # Êü•ËØ¢Áä∂ÊÄÅ
    status = task_queue.get_task_status(task_id)
    print(f"‰ªªÂä°Áä∂ÊÄÅ: {status}")

    # Á≠âÂæÖÂ§ÑÁêÜ
    time.sleep(2)

    # ÂÜçÊ¨°Êü•ËØ¢Áä∂ÊÄÅ
    status = task_queue.get_task_status(task_id)
    print(f"ÊúÄÁªàÁä∂ÊÄÅ: {status}")

    # ÂÅúÊ≠¢ÈòüÂàó
    task_queue.stop()
